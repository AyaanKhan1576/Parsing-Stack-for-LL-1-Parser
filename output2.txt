Original Grammar:
Grammar:
E -> E + T  | T  | b 
F -> ( E )  | id  | ( F 
T -> T * F  | F  | T id 

Grammar after Left Factoring:
Grammar:
E -> E + T  | T  | b 
F -> ( F'  | id 
F' -> E )  | F 
T -> F  | T T' 
T' -> * F  | id 

Grammar after Left Recursion Elimination:
Grammar:
E -> T E'  | b E' 
E' -> + T E'  | epsilon 
F -> ( F'  | id 
F' -> T E' )  | b E' )  | ( F'  | id 
T -> ( F' T''  | id T'' 
T' -> * F  | id 
T'' -> T' T''  | epsilon 

FIRST Sets:
FIRST(E) = { (, b, id }
FIRST(E') = { +, epsilon }
FIRST(F) = { (, id }
FIRST(F') = { (, b, id }
FIRST(T) = { (, id }
FIRST(T') = { *, id }
FIRST(T'') = { *, epsilon, id }

FOLLOW Sets:
FOLLOW(E) = { $ }
FOLLOW(E') = { $, ) }
FOLLOW(F) = { $, ), *, +, id }
FOLLOW(F') = { $, ), *, +, id }
FOLLOW(T) = { $, ), + }
FOLLOW(T') = { $, ), *, +, id }
FOLLOW(T'') = { $, ), + }

LL(1) Parsing Table:
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|               |              $|              (|              )|              *|              +|              b|             id|
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|              E|               |     E -> T E' |               |               |               |     E -> b E' |     E -> T E' |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|             E'| E' -> epsilon |               | E' -> epsilon |               |  E' -> + T E' |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|              F|               |     F -> ( F' |               |               |               |               |       F -> id |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|             F'|               |    F' -> ( F' |               |               |               |  F' -> b E' ) |      F' -> id |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|              T|               | T -> ( F' T'' |               |               |               |               |   T -> id T'' |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|             T'|               |               |               |     T' -> * F |               |               |      T' -> id |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|            T''|T'' -> epsilon |               |T'' -> epsilon | T'' -> T' T'' |T'' -> epsilon |               | T'' -> T' T'' |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+

===== PARSING INPUT STRINGS =====

Line 1: (a + b) * (a + b + a)
Beginning parse of input string
Current token: (
Stack: [ $ E ]
Input: id + b ) * ( id + b + id ) $
Apply production: E -> T E' 
Stack: [ $ E' T ]
Input: id + b ) * ( id + b + id ) $
Apply production: T -> ( F' T'' 
Stack: [ $ E' T'' F' ( ]
Input: id + b ) * ( id + b + id ) $
Match and Pop: (
Next token: id
Stack: [ $ E' T'' F' ]
Input: + b ) * ( id + b + id ) $
Apply production: F' -> id 
Stack: [ $ E' T'' id ]
Input: + b ) * ( id + b + id ) $
Match and Pop: id
Next token: +
Stack: [ $ E' T'' ]
Input: b ) * ( id + b + id ) $
Apply production: T'' -> epsilon 
(Applying epsilon)
Stack: [ $ E' ]
Input: b ) * ( id + b + id ) $
Apply production: E' -> + T E' 
Stack: [ $ E' T + ]
Input: b ) * ( id + b + id ) $
Match and Pop: +
Next token: b
Stack: [ $ E' T ]
Input: ) * ( id + b + id ) $
Syntax Error (Line 1): No production for [T, b]
Error Recovery: Skipping token 'b'
Stack: [ $ E' T ]
Input: * ( id + b + id ) $
Syntax Error (Line 1): No production for [T, )]
Error Recovery: Skipping token ')'
Stack: [ $ E' T ]
Input: ( id + b + id ) $
Syntax Error (Line 1): No production for [T, *]
Error Recovery: Skipping token '*'
Stack: [ $ E' T ]
Input: id + b + id ) $
Apply production: T -> ( F' T'' 
Stack: [ $ E' T'' F' ( ]
Input: id + b + id ) $
Match and Pop: (
Next token: id
Stack: [ $ E' T'' F' ]
Input: + b + id ) $
Apply production: F' -> id 
Stack: [ $ E' T'' id ]
Input: + b + id ) $
Match and Pop: id
Next token: +
Stack: [ $ E' T'' ]
Input: b + id ) $
Apply production: T'' -> epsilon 
(Applying epsilon)
Stack: [ $ E' ]
Input: b + id ) $
Apply production: E' -> + T E' 
Stack: [ $ E' T + ]
Input: b + id ) $
Match and Pop: +
Next token: b
Stack: [ $ E' T ]
Input: + id ) $
Syntax Error (Line 1): No production for [T, b]
Error Recovery: Skipping token 'b'
Stack: [ $ E' T ]
Input: id ) $
Syntax Error (Line 1): No production for [T, +]
Error Recovery: Skipping token '+'
Stack: [ $ E' T ]
Input: ) $
Apply production: T -> id T'' 
Stack: [ $ E' T'' id ]
Input: ) $
Match and Pop: id
Next token: )
Stack: [ $ E' T'' ]
Input: $
Apply production: T'' -> epsilon 
(Applying epsilon)
Stack: [ $ E' ]
Input: $
Apply production: E' -> epsilon 
(Applying epsilon)
Stack: [ $ ]
Input: $
Internal Parser Error: Unexpected stack top '$'
-----------------------------

Parsing completed with 1 error(s).

Processing complete.
