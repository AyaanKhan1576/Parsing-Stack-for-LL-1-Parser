Original Grammar:
Grammar:
ASSIGN -> id = EXPR ; 
COND -> EXPR REL_OP EXPR 
DECL -> int id ; 
EXPR -> TERM EXPR_TAIL 
EXPR_TAIL -> + TERM EXPR_TAIL  | - TERM EXPR_TAIL  | epsilon 
IF_STMT -> if ( COND ) { STMT_LIST } 
PROGRAM -> STMT_LIST 
REL_OP -> >  | <  | ==  | !=  | >=  | <= 
STMT -> DECL  | ASSIGN  | IF_STMT 
STMT_LIST -> STMT STMT_LIST  | epsilon 
TERM -> id  | int_lit  | ( EXPR ) 

Grammar after Left Factoring:
Grammar:
ASSIGN -> id = EXPR ; 
COND -> EXPR REL_OP EXPR 
DECL -> int id ; 
EXPR -> TERM EXPR_TAIL 
EXPR_TAIL -> + TERM EXPR_TAIL  | - TERM EXPR_TAIL  | epsilon 
IF_STMT -> if ( COND ) { STMT_LIST } 
PROGRAM -> STMT_LIST 
REL_OP -> >  | <  | ==  | !=  | >=  | <= 
STMT -> DECL  | ASSIGN  | IF_STMT 
STMT_LIST -> STMT STMT_LIST  | epsilon 
TERM -> id  | int_lit  | ( EXPR ) 

Grammar after Left Recursion Elimination:
Grammar:
ASSIGN -> id = EXPR ; 
COND -> EXPR REL_OP EXPR 
DECL -> int id ; 
EXPR -> TERM EXPR_TAIL 
EXPR_TAIL -> + TERM EXPR_TAIL  | - TERM EXPR_TAIL  | epsilon 
IF_STMT -> if ( COND ) { STMT_LIST } 
PROGRAM -> STMT_LIST 
REL_OP -> >  | <  | ==  | !=  | >=  | <= 
STMT -> int id ;  | id = EXPR ;  | if ( COND ) { STMT_LIST } 
STMT_LIST -> int id ; STMT_LIST  | id = EXPR ; STMT_LIST  | if ( COND ) { STMT_LIST } STMT_LIST  | epsilon 
TERM -> id  | int_lit  | ( EXPR ) 

FIRST Sets:
FIRST(ASSIGN) = { id }
FIRST(COND) = { (, id, int_lit }
FIRST(DECL) = { int }
FIRST(EXPR) = { (, id, int_lit }
FIRST(EXPR_TAIL) = { +, -, epsilon }
FIRST(IF_STMT) = { if }
FIRST(PROGRAM) = { epsilon, id, if, int }
FIRST(REL_OP) = { !=, <, <=, ==, >, >= }
FIRST(STMT) = { id, if, int }
FIRST(STMT_LIST) = { epsilon, id, if, int }
FIRST(TERM) = { (, id, int_lit }

FOLLOW Sets:
FOLLOW(ASSIGN) = {  }
FOLLOW(COND) = { ) }
FOLLOW(DECL) = {  }
FOLLOW(EXPR) = { !=, ), ;, <, <=, ==, >, >= }
FOLLOW(EXPR_TAIL) = { !=, ), ;, <, <=, ==, >, >= }
FOLLOW(IF_STMT) = {  }
FOLLOW(PROGRAM) = { $ }
FOLLOW(REL_OP) = { (, id, int_lit }
FOLLOW(STMT) = {  }
FOLLOW(STMT_LIST) = { $, } }
FOLLOW(TERM) = { !=, ), +, -, ;, <, <=, ==, >, >= }

LL(1) Parsing Table:
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|               |             !=|              $|              (|              )|              +|              -|              ;|              <|             <=|              =|             ==|              >|             >=|             id|             if|            int|        int_lit|              {|              }|
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|         ASSIGN|               |               |               |               |               |               |               |               |               |               |               |               |               |ASSIGN -> id = EXPR ; |               |               |               |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|           COND|               |               |COND -> EXPR REL_OP EXPR |               |               |               |               |               |               |               |               |               |               |COND -> EXPR REL_OP EXPR |               |               |COND -> EXPR REL_OP EXPR |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|           DECL|               |               |               |               |               |               |               |               |               |               |               |               |               |               |               |DECL -> int id ; |               |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|           EXPR|               |               |EXPR -> TERM EXPR_TAIL |               |               |               |               |               |               |               |               |               |               |EXPR -> TERM EXPR_TAIL |               |               |EXPR -> TERM EXPR_TAIL |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|      EXPR_TAIL|EXPR_TAIL -> epsilon |               |               |EXPR_TAIL -> epsilon |EXPR_TAIL -> + TERM EXPR_TAIL |EXPR_TAIL -> - TERM EXPR_TAIL |EXPR_TAIL -> epsilon |EXPR_TAIL -> epsilon |EXPR_TAIL -> epsilon |               |EXPR_TAIL -> epsilon |EXPR_TAIL -> epsilon |EXPR_TAIL -> epsilon |               |               |               |               |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|        IF_STMT|               |               |               |               |               |               |               |               |               |               |               |               |               |               |IF_STMT -> if ( COND ) { STMT_LIST } |               |               |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|        PROGRAM|               |PROGRAM -> STMT_LIST |               |               |               |               |               |               |               |               |               |               |               |PROGRAM -> STMT_LIST |PROGRAM -> STMT_LIST |PROGRAM -> STMT_LIST |               |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|         REL_OP|  REL_OP -> != |               |               |               |               |               |               |   REL_OP -> < |  REL_OP -> <= |               |  REL_OP -> == |   REL_OP -> > |  REL_OP -> >= |               |               |               |               |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|           STMT|               |               |               |               |               |               |               |               |               |               |               |               |               |STMT -> id = EXPR ; |STMT -> if ( COND ) { STMT_LIST } |STMT -> int id ; |               |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|      STMT_LIST|               |STMT_LIST -> epsilon |               |               |               |               |               |               |               |               |               |               |               |STMT_LIST -> id = EXPR ; STMT_LIST |STMT_LIST -> if ( COND ) { STMT_LIST } STMT_LIST |STMT_LIST -> int id ; STMT_LIST |               |               |STMT_LIST -> epsilon |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|           TERM|               |               |TERM -> ( EXPR ) |               |               |               |               |               |               |               |               |               |               |    TERM -> id |               |               |TERM -> int_lit |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+

===== PARSING INPUT STRINGS =====

Line 1: int x ;
Beginning parse of input string
Current token: int
Stack: [ $ PROGRAM ]
Input: id ; $
Apply production: PROGRAM -> STMT_LIST 
Stack: [ $ STMT_LIST ]
Input: id ; $
Apply production: STMT_LIST -> int id ; STMT_LIST 
Stack: [ $ STMT_LIST ; id int ]
Input: id ; $
Match and Pop: int
Next token: id
Stack: [ $ STMT_LIST ; id ]
Input: ; $
Match and Pop: id
Next token: ;
Stack: [ $ STMT_LIST ; ]
Input: $
Match and Pop: ;
Next token: $
Stack: [ $ STMT_LIST ]
Input: $
Apply production: STMT_LIST -> epsilon 
(Applying epsilon)
Stack: [ $ ]
Input: $
Processing complete for the line.
Parse successful!
-----------------------------

Line 2: x = 5 + 2 ;
Beginning parse of input string
Current token: id
Stack: [ $ PROGRAM ]
Input: = int_lit + int_lit ; $
Apply production: PROGRAM -> STMT_LIST 
Stack: [ $ STMT_LIST ]
Input: = int_lit + int_lit ; $
Apply production: STMT_LIST -> id = EXPR ; STMT_LIST 
Stack: [ $ STMT_LIST ; EXPR = id ]
Input: = int_lit + int_lit ; $
Match and Pop: id
Next token: =
Stack: [ $ STMT_LIST ; EXPR = ]
Input: int_lit + int_lit ; $
Match and Pop: =
Next token: int_lit
Stack: [ $ STMT_LIST ; EXPR ]
Input: + int_lit ; $
Apply production: EXPR -> TERM EXPR_TAIL 
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: + int_lit ; $
Apply production: TERM -> int_lit 
Stack: [ $ STMT_LIST ; EXPR_TAIL int_lit ]
Input: + int_lit ; $
Match and Pop: int_lit
Next token: +
Stack: [ $ STMT_LIST ; EXPR_TAIL ]
Input: int_lit ; $
Apply production: EXPR_TAIL -> + TERM EXPR_TAIL 
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM + ]
Input: int_lit ; $
Match and Pop: +
Next token: int_lit
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: ; $
Apply production: TERM -> int_lit 
Stack: [ $ STMT_LIST ; EXPR_TAIL int_lit ]
Input: ; $
Match and Pop: int_lit
Next token: ;
Stack: [ $ STMT_LIST ; EXPR_TAIL ]
Input: $
Apply production: EXPR_TAIL -> epsilon 
(Applying epsilon)
Stack: [ $ STMT_LIST ; ]
Input: $
Match and Pop: ;
Next token: $
Stack: [ $ STMT_LIST ]
Input: $
Apply production: STMT_LIST -> epsilon 
(Applying epsilon)
Stack: [ $ ]
Input: $
Processing complete for the line.
Parse successful!
-----------------------------

Line 3: x = 5 + ;
Beginning parse of input string
Current token: id
Stack: [ $ PROGRAM ]
Input: = int_lit + ; $
Apply production: PROGRAM -> STMT_LIST 
Stack: [ $ STMT_LIST ]
Input: = int_lit + ; $
Apply production: STMT_LIST -> id = EXPR ; STMT_LIST 
Stack: [ $ STMT_LIST ; EXPR = id ]
Input: = int_lit + ; $
Match and Pop: id
Next token: =
Stack: [ $ STMT_LIST ; EXPR = ]
Input: int_lit + ; $
Match and Pop: =
Next token: int_lit
Stack: [ $ STMT_LIST ; EXPR ]
Input: + ; $
Apply production: EXPR -> TERM EXPR_TAIL 
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: + ; $
Apply production: TERM -> int_lit 
Stack: [ $ STMT_LIST ; EXPR_TAIL int_lit ]
Input: + ; $
Match and Pop: int_lit
Next token: +
Stack: [ $ STMT_LIST ; EXPR_TAIL ]
Input: ; $
Apply production: EXPR_TAIL -> + TERM EXPR_TAIL 
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM + ]
Input: ; $
Match and Pop: +
Next token: ;
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Syntax Error (Line 3): No production for [TERM, ;]
Error Recovery: Skipping token ';'
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Syntax Error (Line 3): No production for [TERM, $]
Error Recovery: Skipping token '$'
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Syntax Error (Line 3): No production for [TERM, $]
Error Recovery: Skipping token '$'
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Syntax Error (Line 3): No production for [TERM, $]
Error Recovery: Skipping token '$'
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Syntax Error (Line 3): No production for [TERM, $]
Error Recovery: Skipping token '$'
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Syntax Error (Line 3): No production for [TERM, $]
Error Recovery: Skipping token '$'
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Syntax Error (Line 3): No production for [TERM, $]
Error Recovery: Skipping token '$'
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Syntax Error (Line 3): No production for [TERM, $]
Error Recovery: Skipping token '$'
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Syntax Error (Line 3): No production for [TERM, $]
Error Recovery: Skipping token '$'
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Syntax Error (Line 3): No production for [TERM, $]
Error Recovery: Skipping token '$'
Stack: [ $ STMT_LIST ; EXPR_TAIL TERM ]
Input: $
Too many consecutive errors. Giving up on line 3.
Parse failed due to syntax errors detected on line 3.
-----------------------------

Line 4: if ( x > 0 ) { x = x - 1 ; }
Beginning parse of input string
Current token: if
Stack: [ $ PROGRAM ]
Input: ( id > int_lit ) { id = id - int_lit ; } $
Apply production: PROGRAM -> STMT_LIST 
Stack: [ $ STMT_LIST ]
Input: ( id > int_lit ) { id = id - int_lit ; } $
Apply production: STMT_LIST -> if ( COND ) { STMT_LIST } STMT_LIST 
Stack: [ $ STMT_LIST } STMT_LIST { ) COND ( if ]
Input: ( id > int_lit ) { id = id - int_lit ; } $
Match and Pop: if
Next token: (
Stack: [ $ STMT_LIST } STMT_LIST { ) COND ( ]
Input: id > int_lit ) { id = id - int_lit ; } $
Match and Pop: (
Next token: id
Stack: [ $ STMT_LIST } STMT_LIST { ) COND ]
Input: > int_lit ) { id = id - int_lit ; } $
Apply production: COND -> EXPR REL_OP EXPR 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR REL_OP EXPR ]
Input: > int_lit ) { id = id - int_lit ; } $
Apply production: EXPR -> TERM EXPR_TAIL 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR REL_OP EXPR_TAIL TERM ]
Input: > int_lit ) { id = id - int_lit ; } $
Apply production: TERM -> id 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR REL_OP EXPR_TAIL id ]
Input: > int_lit ) { id = id - int_lit ; } $
Match and Pop: id
Next token: >
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR REL_OP EXPR_TAIL ]
Input: int_lit ) { id = id - int_lit ; } $
Apply production: EXPR_TAIL -> epsilon 
(Applying epsilon)
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR REL_OP ]
Input: int_lit ) { id = id - int_lit ; } $
Apply production: REL_OP -> > 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR > ]
Input: int_lit ) { id = id - int_lit ; } $
Match and Pop: >
Next token: int_lit
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR ]
Input: ) { id = id - int_lit ; } $
Apply production: EXPR -> TERM EXPR_TAIL 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL TERM ]
Input: ) { id = id - int_lit ; } $
Apply production: TERM -> int_lit 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL int_lit ]
Input: ) { id = id - int_lit ; } $
Match and Pop: int_lit
Next token: )
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL ]
Input: { id = id - int_lit ; } $
Apply production: EXPR_TAIL -> epsilon 
(Applying epsilon)
Stack: [ $ STMT_LIST } STMT_LIST { ) ]
Input: { id = id - int_lit ; } $
Match and Pop: )
Next token: {
Stack: [ $ STMT_LIST } STMT_LIST { ]
Input: id = id - int_lit ; } $
Match and Pop: {
Next token: id
Stack: [ $ STMT_LIST } STMT_LIST ]
Input: = id - int_lit ; } $
Apply production: STMT_LIST -> id = EXPR ; STMT_LIST 
Stack: [ $ STMT_LIST } STMT_LIST ; EXPR = id ]
Input: = id - int_lit ; } $
Match and Pop: id
Next token: =
Stack: [ $ STMT_LIST } STMT_LIST ; EXPR = ]
Input: id - int_lit ; } $
Match and Pop: =
Next token: id
Stack: [ $ STMT_LIST } STMT_LIST ; EXPR ]
Input: - int_lit ; } $
Apply production: EXPR -> TERM EXPR_TAIL 
Stack: [ $ STMT_LIST } STMT_LIST ; EXPR_TAIL TERM ]
Input: - int_lit ; } $
Apply production: TERM -> id 
Stack: [ $ STMT_LIST } STMT_LIST ; EXPR_TAIL id ]
Input: - int_lit ; } $
Match and Pop: id
Next token: -
Stack: [ $ STMT_LIST } STMT_LIST ; EXPR_TAIL ]
Input: int_lit ; } $
Apply production: EXPR_TAIL -> - TERM EXPR_TAIL 
Stack: [ $ STMT_LIST } STMT_LIST ; EXPR_TAIL TERM - ]
Input: int_lit ; } $
Match and Pop: -
Next token: int_lit
Stack: [ $ STMT_LIST } STMT_LIST ; EXPR_TAIL TERM ]
Input: ; } $
Apply production: TERM -> int_lit 
Stack: [ $ STMT_LIST } STMT_LIST ; EXPR_TAIL int_lit ]
Input: ; } $
Match and Pop: int_lit
Next token: ;
Stack: [ $ STMT_LIST } STMT_LIST ; EXPR_TAIL ]
Input: } $
Apply production: EXPR_TAIL -> epsilon 
(Applying epsilon)
Stack: [ $ STMT_LIST } STMT_LIST ; ]
Input: } $
Match and Pop: ;
Next token: }
Stack: [ $ STMT_LIST } STMT_LIST ]
Input: $
Apply production: STMT_LIST -> epsilon 
(Applying epsilon)
Stack: [ $ STMT_LIST } ]
Input: $
Match and Pop: }
Next token: $
Stack: [ $ STMT_LIST ]
Input: $
Apply production: STMT_LIST -> epsilon 
(Applying epsilon)
Stack: [ $ ]
Input: $
Processing complete for the line.
Parse successful!
-----------------------------

Line 5: if ( x > 0 { x = x - 1 ; }
Beginning parse of input string
Current token: if
Stack: [ $ PROGRAM ]
Input: ( id > int_lit { id = id - int_lit ; } $
Apply production: PROGRAM -> STMT_LIST 
Stack: [ $ STMT_LIST ]
Input: ( id > int_lit { id = id - int_lit ; } $
Apply production: STMT_LIST -> if ( COND ) { STMT_LIST } STMT_LIST 
Stack: [ $ STMT_LIST } STMT_LIST { ) COND ( if ]
Input: ( id > int_lit { id = id - int_lit ; } $
Match and Pop: if
Next token: (
Stack: [ $ STMT_LIST } STMT_LIST { ) COND ( ]
Input: id > int_lit { id = id - int_lit ; } $
Match and Pop: (
Next token: id
Stack: [ $ STMT_LIST } STMT_LIST { ) COND ]
Input: > int_lit { id = id - int_lit ; } $
Apply production: COND -> EXPR REL_OP EXPR 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR REL_OP EXPR ]
Input: > int_lit { id = id - int_lit ; } $
Apply production: EXPR -> TERM EXPR_TAIL 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR REL_OP EXPR_TAIL TERM ]
Input: > int_lit { id = id - int_lit ; } $
Apply production: TERM -> id 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR REL_OP EXPR_TAIL id ]
Input: > int_lit { id = id - int_lit ; } $
Match and Pop: id
Next token: >
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR REL_OP EXPR_TAIL ]
Input: int_lit { id = id - int_lit ; } $
Apply production: EXPR_TAIL -> epsilon 
(Applying epsilon)
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR REL_OP ]
Input: int_lit { id = id - int_lit ; } $
Apply production: REL_OP -> > 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR > ]
Input: int_lit { id = id - int_lit ; } $
Match and Pop: >
Next token: int_lit
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR ]
Input: { id = id - int_lit ; } $
Apply production: EXPR -> TERM EXPR_TAIL 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL TERM ]
Input: { id = id - int_lit ; } $
Apply production: TERM -> int_lit 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL int_lit ]
Input: { id = id - int_lit ; } $
Match and Pop: int_lit
Next token: {
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL ]
Input: id = id - int_lit ; } $
Syntax Error (Line 5): No production for [EXPR_TAIL, {]
Error Recovery: Skipping token '{'
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL ]
Input: = id - int_lit ; } $
Syntax Error (Line 5): No production for [EXPR_TAIL, id]
Error Recovery: Skipping token 'id'
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL ]
Input: id - int_lit ; } $
Syntax Error (Line 5): No production for [EXPR_TAIL, =]
Error Recovery: Skipping token '='
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL ]
Input: - int_lit ; } $
Syntax Error (Line 5): No production for [EXPR_TAIL, id]
Error Recovery: Skipping token 'id'
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL ]
Input: int_lit ; } $
Apply production: EXPR_TAIL -> - TERM EXPR_TAIL 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL TERM - ]
Input: int_lit ; } $
Match and Pop: -
Next token: int_lit
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL TERM ]
Input: ; } $
Apply production: TERM -> int_lit 
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL int_lit ]
Input: ; } $
Match and Pop: int_lit
Next token: ;
Stack: [ $ STMT_LIST } STMT_LIST { ) EXPR_TAIL ]
Input: } $
Apply production: EXPR_TAIL -> epsilon 
(Applying epsilon)
Stack: [ $ STMT_LIST } STMT_LIST { ) ]
Input: } $
Syntax Error (Line 5): Mismatch. Expected ')', but found ';'
Error Recovery: Popping ')' from stack.
Stack: [ $ STMT_LIST } STMT_LIST { ]
Input: } $
Syntax Error (Line 5): Mismatch. Expected '{', but found ';'
Error Recovery: Popping '{' from stack.
Stack: [ $ STMT_LIST } STMT_LIST ]
Input: } $
Syntax Error (Line 5): No production for [STMT_LIST, ;]
Error Recovery: Skipping token ';'
Stack: [ $ STMT_LIST } STMT_LIST ]
Input: $
Apply production: STMT_LIST -> epsilon 
(Applying epsilon)
Stack: [ $ STMT_LIST } ]
Input: $
Match and Pop: }
Next token: $
Stack: [ $ STMT_LIST ]
Input: $
Apply production: STMT_LIST -> epsilon 
(Applying epsilon)
Stack: [ $ ]
Input: $
Processing complete for the line.
Parse failed due to syntax errors detected on line 5.
-----------------------------

Parsing completed with 2 error(s).

Processing complete.
