Original Grammar:
Grammar:
Declaration -> int id = Expression ;  | int id ; 
E' -> + T E'  | epsilon 
Expression -> T E' 
F -> id  | ( Expression )  | int_lit 
Program -> Statement Program  | epsilon 
Statement -> Declaration  | Expression ; 
T -> F T' 
T' -> * F T'  | epsilon 

Grammar after Left Factoring:
Grammar:
Declaration -> int Declaration' 
Declaration' -> id Declaration'' 
Declaration'' -> = Expression ;  | ; 
E' -> + T E'  | epsilon 
Expression -> T E' 
F -> id  | ( Expression )  | int_lit 
Program -> Statement Program  | epsilon 
Statement -> Declaration  | Expression ; 
T -> F T' 
T' -> * F T'  | epsilon 

Grammar after Left Recursion Elimination:
Grammar:
Declaration -> int Declaration' 
Declaration' -> id Declaration'' 
Declaration'' -> = Expression ;  | ; 
E' -> + T E'  | epsilon 
Expression -> T E' 
F -> id  | ( Expression )  | int_lit 
Program -> Statement Program  | epsilon 
Statement -> int Declaration'  | T E' ; 
T -> id T'  | ( Expression ) T'  | int_lit T' 
T' -> * F T'  | epsilon 

FIRST Sets:
FIRST(Declaration) = { int }
FIRST(Declaration') = { id }
FIRST(Declaration'') = { ;, = }
FIRST(E') = { +, epsilon }
FIRST(Expression) = { (, id, int_lit }
FIRST(F) = { (, id, int_lit }
FIRST(Program) = { (, epsilon, id, int, int_lit }
FIRST(Statement) = { (, id, int, int_lit }
FIRST(T) = { (, id, int_lit }
FIRST(T') = { *, epsilon }

FOLLOW Sets:
FOLLOW(Declaration) = {  }
FOLLOW(Declaration') = { $, (, id, int, int_lit }
FOLLOW(Declaration'') = { $, (, id, int, int_lit }
FOLLOW(E') = { ), ; }
FOLLOW(Expression) = { ), ; }
FOLLOW(F) = { ), *, +, ; }
FOLLOW(Program) = { $ }
FOLLOW(Statement) = { $, (, id, int, int_lit }
FOLLOW(T) = { ), +, ; }
FOLLOW(T') = { ), +, ; }

LL(1) Parsing Table:
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|               |              $|              (|              )|              *|              +|              ;|              =|             id|            int|        int_lit|
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|    Declaration|               |               |               |               |               |               |               |               |Declaration -> int Declaration' |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|   Declaration'|               |               |               |               |               |               |               |Declaration' -> id Declaration'' |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|  Declaration''|               |               |               |               |               |Declaration'' -> ; |Declaration'' -> = Expression ; |               |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|             E'|               |               | E' -> epsilon |               |  E' -> + T E' | E' -> epsilon |               |               |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|     Expression|               |Expression -> T E' |               |               |               |               |               |Expression -> T E' |               |Expression -> T E' |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|              F|               |F -> ( Expression ) |               |               |               |               |               |       F -> id |               |  F -> int_lit |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|        Program|Program -> epsilon |Program -> Statement Program |               |               |               |               |               |Program -> Statement Program |Program -> Statement Program |Program -> Statement Program |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|      Statement|               |Statement -> T E' ; |               |               |               |               |               |Statement -> T E' ; |Statement -> int Declaration' |Statement -> T E' ; |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|              T|               |T -> ( Expression ) T' |               |               |               |               |               |    T -> id T' |               |T -> int_lit T' |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|             T'|               |               | T' -> epsilon |  T' -> * F T' | T' -> epsilon | T' -> epsilon |               |               |               |               |
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+

===== PARSING INPUT STRINGS =====

Line 1: int a ;
Beginning parse of input string
Current token: int
Stack: [ $ Program ]
Input: id ; $
Apply production: Program -> Statement Program 
Stack: [ $ Program Statement ]
Input: id ; $
Apply production: Statement -> int Declaration' 
Stack: [ $ Program Declaration' int ]
Input: id ; $
Match and Pop: int
Next token: id
Stack: [ $ Program Declaration' ]
Input: ; $
Apply production: Declaration' -> id Declaration'' 
Stack: [ $ Program Declaration'' id ]
Input: ; $
Match and Pop: id
Next token: ;
Stack: [ $ Program Declaration'' ]
Input: $
Apply production: Declaration'' -> ; 
Stack: [ $ Program ; ]
Input: $
Match and Pop: ;
Next token: $
Stack: [ $ Program ]
Input: $
Apply production: Program -> epsilon 
(Applying epsilon)
Stack: [ $ ]
Input: $
Processing complete for the line.
Parse successful!
-----------------------------

Line 2: int b = 10 ;
Beginning parse of input string
Current token: int
Stack: [ $ Program ]
Input: id = int_lit ; $
Apply production: Program -> Statement Program 
Stack: [ $ Program Statement ]
Input: id = int_lit ; $
Apply production: Statement -> int Declaration' 
Stack: [ $ Program Declaration' int ]
Input: id = int_lit ; $
Match and Pop: int
Next token: id
Stack: [ $ Program Declaration' ]
Input: = int_lit ; $
Apply production: Declaration' -> id Declaration'' 
Stack: [ $ Program Declaration'' id ]
Input: = int_lit ; $
Match and Pop: id
Next token: =
Stack: [ $ Program Declaration'' ]
Input: int_lit ; $
Apply production: Declaration'' -> = Expression ; 
Stack: [ $ Program ; Expression = ]
Input: int_lit ; $
Match and Pop: =
Next token: int_lit
Stack: [ $ Program ; Expression ]
Input: ; $
Apply production: Expression -> T E' 
Stack: [ $ Program ; E' T ]
Input: ; $
Apply production: T -> int_lit T' 
Stack: [ $ Program ; E' T' int_lit ]
Input: ; $
Match and Pop: int_lit
Next token: ;
Stack: [ $ Program ; E' T' ]
Input: $
Apply production: T' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; E' ]
Input: $
Apply production: E' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; ]
Input: $
Match and Pop: ;
Next token: $
Stack: [ $ Program ]
Input: $
Apply production: Program -> epsilon 
(Applying epsilon)
Stack: [ $ ]
Input: $
Processing complete for the line.
Parse successful!
-----------------------------

Line 3: int c = (a + b) * (a + b + a) ;
Beginning parse of input string
Current token: int
Stack: [ $ Program ]
Input: id = ( id + id ) * ( id + id + id ) ; $
Apply production: Program -> Statement Program 
Stack: [ $ Program Statement ]
Input: id = ( id + id ) * ( id + id + id ) ; $
Apply production: Statement -> int Declaration' 
Stack: [ $ Program Declaration' int ]
Input: id = ( id + id ) * ( id + id + id ) ; $
Match and Pop: int
Next token: id
Stack: [ $ Program Declaration' ]
Input: = ( id + id ) * ( id + id + id ) ; $
Apply production: Declaration' -> id Declaration'' 
Stack: [ $ Program Declaration'' id ]
Input: = ( id + id ) * ( id + id + id ) ; $
Match and Pop: id
Next token: =
Stack: [ $ Program Declaration'' ]
Input: ( id + id ) * ( id + id + id ) ; $
Apply production: Declaration'' -> = Expression ; 
Stack: [ $ Program ; Expression = ]
Input: ( id + id ) * ( id + id + id ) ; $
Match and Pop: =
Next token: (
Stack: [ $ Program ; Expression ]
Input: id + id ) * ( id + id + id ) ; $
Apply production: Expression -> T E' 
Stack: [ $ Program ; E' T ]
Input: id + id ) * ( id + id + id ) ; $
Apply production: T -> ( Expression ) T' 
Stack: [ $ Program ; E' T' ) Expression ( ]
Input: id + id ) * ( id + id + id ) ; $
Match and Pop: (
Next token: id
Stack: [ $ Program ; E' T' ) Expression ]
Input: + id ) * ( id + id + id ) ; $
Apply production: Expression -> T E' 
Stack: [ $ Program ; E' T' ) E' T ]
Input: + id ) * ( id + id + id ) ; $
Apply production: T -> id T' 
Stack: [ $ Program ; E' T' ) E' T' id ]
Input: + id ) * ( id + id + id ) ; $
Match and Pop: id
Next token: +
Stack: [ $ Program ; E' T' ) E' T' ]
Input: id ) * ( id + id + id ) ; $
Apply production: T' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; E' T' ) E' ]
Input: id ) * ( id + id + id ) ; $
Apply production: E' -> + T E' 
Stack: [ $ Program ; E' T' ) E' T + ]
Input: id ) * ( id + id + id ) ; $
Match and Pop: +
Next token: id
Stack: [ $ Program ; E' T' ) E' T ]
Input: ) * ( id + id + id ) ; $
Apply production: T -> id T' 
Stack: [ $ Program ; E' T' ) E' T' id ]
Input: ) * ( id + id + id ) ; $
Match and Pop: id
Next token: )
Stack: [ $ Program ; E' T' ) E' T' ]
Input: * ( id + id + id ) ; $
Apply production: T' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; E' T' ) E' ]
Input: * ( id + id + id ) ; $
Apply production: E' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; E' T' ) ]
Input: * ( id + id + id ) ; $
Match and Pop: )
Next token: *
Stack: [ $ Program ; E' T' ]
Input: ( id + id + id ) ; $
Apply production: T' -> * F T' 
Stack: [ $ Program ; E' T' F * ]
Input: ( id + id + id ) ; $
Match and Pop: *
Next token: (
Stack: [ $ Program ; E' T' F ]
Input: id + id + id ) ; $
Apply production: F -> ( Expression ) 
Stack: [ $ Program ; E' T' ) Expression ( ]
Input: id + id + id ) ; $
Match and Pop: (
Next token: id
Stack: [ $ Program ; E' T' ) Expression ]
Input: + id + id ) ; $
Apply production: Expression -> T E' 
Stack: [ $ Program ; E' T' ) E' T ]
Input: + id + id ) ; $
Apply production: T -> id T' 
Stack: [ $ Program ; E' T' ) E' T' id ]
Input: + id + id ) ; $
Match and Pop: id
Next token: +
Stack: [ $ Program ; E' T' ) E' T' ]
Input: id + id ) ; $
Apply production: T' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; E' T' ) E' ]
Input: id + id ) ; $
Apply production: E' -> + T E' 
Stack: [ $ Program ; E' T' ) E' T + ]
Input: id + id ) ; $
Match and Pop: +
Next token: id
Stack: [ $ Program ; E' T' ) E' T ]
Input: + id ) ; $
Apply production: T -> id T' 
Stack: [ $ Program ; E' T' ) E' T' id ]
Input: + id ) ; $
Match and Pop: id
Next token: +
Stack: [ $ Program ; E' T' ) E' T' ]
Input: id ) ; $
Apply production: T' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; E' T' ) E' ]
Input: id ) ; $
Apply production: E' -> + T E' 
Stack: [ $ Program ; E' T' ) E' T + ]
Input: id ) ; $
Match and Pop: +
Next token: id
Stack: [ $ Program ; E' T' ) E' T ]
Input: ) ; $
Apply production: T -> id T' 
Stack: [ $ Program ; E' T' ) E' T' id ]
Input: ) ; $
Match and Pop: id
Next token: )
Stack: [ $ Program ; E' T' ) E' T' ]
Input: ; $
Apply production: T' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; E' T' ) E' ]
Input: ; $
Apply production: E' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; E' T' ) ]
Input: ; $
Match and Pop: )
Next token: ;
Stack: [ $ Program ; E' T' ]
Input: $
Apply production: T' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; E' ]
Input: $
Apply production: E' -> epsilon 
(Applying epsilon)
Stack: [ $ Program ; ]
Input: $
Match and Pop: ;
Next token: $
Stack: [ $ Program ]
Input: $
Apply production: Program -> epsilon 
(Applying epsilon)
Stack: [ $ ]
Input: $
Processing complete for the line.
Parse successful!
-----------------------------

Parsing completed with 0 error(s).

Processing complete.
